<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom" 
     xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>volter9.github.io</title>
        <description>Личный блог volter9</description>
        <link>http://volter9.github.io</link>
        
        <atom:link href="http://volter9.github.io/feed/" 
                   rel="self" 
                   type="application/rss+xml"/>
        
         
        <item>
            <title>extract и compact</title>
            
            <link>http://volter9.github.io/blog/php-extract-and-compact/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/php-extract-and-compact/</guid>
            
            <description>&lt;p&gt;В этом посте я расскажу о двух очень полезных функциях которыми я очень часто
пользуюсь и о которых, наверное, мало кто знает или считает плохой практикой. &lt;/p&gt;
&lt;p&gt;Для начала я скажу что управление областью видимости не является плохой вещью.
По моему мнению, нету плохого и хорошего в программирование. Есть просто разные
инструменты и техники для решение определенных задач.&lt;/p&gt;
&lt;p class="notice"&gt;
&lt;b&gt;Внимание&lt;/b&gt;: в параграфе выше я не утверждаю что нужно пользоватся только  
синглетонами, глобальными переменными и &lt;code&gt;goto&lt;/code&gt;. Каждый решает для 
себя какую технику использовать и имеет право на мнение против/за разные практики.
&lt;/p&gt;
&lt;p&gt;Теперь перейдем к самому интересному, самим функциям &lt;code&gt;extract&lt;/code&gt; и &lt;code&gt;compact&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;extract&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/function.extract.php"&gt;extract&lt;/a&gt; функция распаковывает
значение из ассоциативного массива в данную область видимости. Аналогичный код
который делает тоже самое что и extract с одним аргументом в виде массива:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;foreach ($assoc_array as $key =&amp;gt; $value) {
    $$key = $value;
}

// vs.

extract($assos_array);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данная функция полезна для следующих задач:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Распаковка переменных в шаблонах в кастомном шаблонизаторе на основе PHP/своего
синтаксиса&lt;/li&gt;
&lt;li&gt;Распаковка переменных для облегчения обращение к ключам ассоциативного массива
&lt;code&gt;$config['abc']&lt;/code&gt; → &lt;code&gt;$abc&lt;/code&gt; (но тут нужно точно знать какие ключи существуют)&lt;/li&gt;
&lt;li&gt;Пседо-эмуляция Python &lt;code&gt;**kwargs&lt;/code&gt; в PHP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования:&lt;/p&gt;
&lt;div class="tabs-container full"&gt;
    &lt;div class="tab"&gt;index.php&lt;/div&gt;
    &lt;div data-tab="index.php"&gt;
&lt;pre class="language-php"&gt;&lt;code&gt;&amp;lt;?php

/**
 * __ нужны для предотвращения перезаписи переменных
 * 
 * @param string $__view__
 * @param array $__data__
 */
function render ($__view__, $__data__) {
    extract($__data__);

    require($__view__);
}

$title = 'Привет мир!';
$text  = 'Длинный текст...';

render('theme/view.php', [
    'title' =&amp;gt; $title,
    'text'  =&amp;gt; $text
]);&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;

    &lt;div class="tab"&gt;theme/view.php&lt;/div&gt;
    &lt;div data-tab="theme/view.php"&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset="utf-8"&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;?php echo $title ?&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;
            &amp;lt;?php echo $title ?&amp;gt; 
        &amp;lt;/h1&amp;gt;

        &amp;lt;p&amp;gt;
            &amp;lt;?php echo $text ?&amp;gt;
        &amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Я уверен что есть еще применение этой функции, но только их пока что не знаю.&lt;/p&gt;
&lt;h2&gt;compact&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/function.compact.php"&gt;compact&lt;/a&gt; функция является
противоположностью функции extract. Данная функция запаковывает массив ключей
или названия переменных, разделенные через запятые, в ассоциативный массив, где
название переменной станет ключем, а значение значением в массиве.&lt;/p&gt;
&lt;p&gt;Эта функция будет полезна в следующих случаях:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Передать из контролера переменные в представление (MVC)&lt;/li&gt;
&lt;li&gt;Вернуть из функции значения переменных в виде массива&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Предыдущий пример можно упростить (укоротить) за счет использования compact:&lt;/p&gt;
&lt;pre class="language-php"&gt;&lt;code&gt;&amp;lt;?php

/**
 * __ нужны для предотвращения перезаписи переменных
 * 
 * @param string $__view__
 * @param array $__data__
 */
function render ($__view__, $__data__) {
    extract($__data__);

    require($__view__);
}

$title = 'Привет мир!';
$text  = 'Длинный текст...';

render('theme/view.php', compact('title', 'text'));&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Эти функции очень полезны для работы с переменными в данной области видимости.
Используйте их там где они нужны. В любом случае, пример был усложнен для
того чтобы показать как работает extract/compact. Первый пример можно упростить
до:&lt;/p&gt;
&lt;pre class="language-php"&gt;&lt;code&gt;&amp;lt;?php

$title = 'Привет мир!';
$text  = 'Длинный текст...';

require 'theme/view.php';&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Всем хорошего дня/вечера!&lt;/p&gt;</description>
            <pubDate>Tue, 03 Nov 2015 20:40:06 -0800</pubDate>
        </item>
         
        <item>
            <title>Трек недели: Bring the Madness</title>
            
            <link>http://volter9.github.io/blog/bring-the-madness/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/bring-the-madness/</guid>
            
            <description>&lt;p&gt;На этой недели я услышал трек от Pegboard Nerds и был несколько удивлен.
Трек отличается от обычного стиля Pegboard Nerds (видимо из-за коллаба с
Excision и Major Apeshit). Трек мне очень понравился и получился в итоге очень
классным. &lt;/p&gt;
&lt;div&gt;
    &lt;iframe width="100%" 
            height="180" 
            scrolling="no" 
            frameborder="no" 
            src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/186853816&amp;amp;color=2288dd&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;show_comments=false&amp;amp;show_user=true&amp;amp;show_reposts=true"&gt;
    &lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;Огромное влияние на дроп в треке оказал Excision, по моему мнению (больше
похоже на Excision чем Pegboard Nerds).&lt;/p&gt;
&lt;p&gt;Данный трек содержит эпичное вступление которое дает ощущение джунглей.
Агрессивный рэп после краткого вступление поддерживает атмосферу джунглей и дроп
окончательно &lt;!-- "I see what you did here" --&gt; возвыщает трек на новую волну
эфиории.&lt;/p&gt;
&lt;p&gt;В общем, трек и вправду приносит безумие в ума слушателей.&lt;/p&gt;</description>
            <pubDate>Fri, 30 Oct 2015 17:50:17 -0700</pubDate>
        </item>
         
        <item>
            <title>Красивые PHP шаблоны</title>
            
            <link>http://volter9.github.io/blog/beautiful-php-templates/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/beautiful-php-templates/</guid>
            
            <description>&lt;p&gt;Привет, данный пост посвящен перфекционистам как я.&lt;/p&gt;
&lt;p&gt;Бывало у тебя такое что когда пишешь PHP/Twig шаблоны в итоге вывод получается
что-то вроде такого?:&lt;/p&gt;
&lt;div class="spoiler"&gt;&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!-- blocks/navigation --&amp;gt;
&amp;lt;nav class="navigation"&amp;gt;
    &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;
            &amp;lt;a href="/"&amp;gt;
            Главная            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
            &amp;lt;a href="/blog"&amp;gt;
            Блог            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
            &amp;lt;a href="/contact"&amp;gt;
            Контакты            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Этот вывод... это же &lt;em&gt;некрасиво&lt;/em&gt;. PHP шаблон имеет такое содержание:&lt;/p&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!-- blocks/navigation --&amp;gt;
&amp;lt;nav class="navigation"&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;?php foreach ($links as $link): ?&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href="&amp;lt;?php echo $link[0] ?&amp;gt;"&amp;gt;
            &amp;lt;?php echo $link[1] ?&amp;gt;
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;?php endforeach; ?&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Да к в чем же проблема? Почему PHP просто не может вывести так как есть в
шаблонах? Что же происходит там в недрах PHP что приводит к искажению
форматирования? Ответ очень прост:&lt;/p&gt;
&lt;p&gt;Закрывающиеся PHP тэги (&lt;code&gt;?&amp;gt;&lt;/code&gt;) удаляют один перенос строки (&lt;code&gt;\n&lt;/code&gt;) в итоге
форматирование шаблонов обрывается. Чтобы предотвратить данную проблему все что
нужно сделать это добавить после каждого &lt;code&gt;?&amp;gt;&lt;/code&gt; пробел.&lt;/p&gt;
&lt;div class="spoiler"&gt;&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!-- blocks/navigation --&amp;gt;
&amp;lt;nav class="navigation"&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;!-- Так намного лучше --&amp;gt;

        &amp;lt;li&amp;gt;
            &amp;lt;a href="/"&amp;gt;
            Главная 
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;

        &amp;lt;li&amp;gt;
            &amp;lt;a href="/blog"&amp;gt;
            Блог 
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;

        &amp;lt;li&amp;gt;
            &amp;lt;a href="/contact"&amp;gt;
            Контакты 
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;

    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вот так то лучше! Это вывод того же самого PHP шаблона, только после каждого
закрывающегося PHP тэга добавлен пробел.&lt;/p&gt;
&lt;h3&gt;Вывод&lt;/h3&gt;
&lt;p&gt;К сожалению, нельзя добится полного контроля над форматированием вывода
PHP шаблонов без потери форматирования в исходном коде.&lt;/p&gt;</description>
            <pubDate>Tue, 27 Oct 2015 07:03:35 -0700</pubDate>
        </item>
         
        <item>
            <title>CMS в 8 строк!</title>
            
            <link>http://volter9.github.io/blog/8-loc-cms/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/8-loc-cms/</guid>
            
            <description>&lt;style type="text/css"&gt;
    /**
     * Говно код, говнокод, 
     * единственный в мире CSS говнокод
     */
    .buy-button {
        background-color: hsl(40, 95%, 66%); 
        border: 0px !important; 
        border-radius: 8px;
        color: #000; 
        font-size: 24px; 
        font-weight: bold; 
        line-height: 140%;

        display: inline-block; 
        margin-left: -8px;
        padding: 0.85em 2em; 
    }

    .buy-button:hover {
        background-color: hsl(40, 100%, 72%); 
    }
&lt;/style&gt;
&lt;p&gt;Привет ребята!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPD&lt;/strong&gt;: CMS из этой крутой статьи теперь на &lt;a href="https://github.com/volter9/8-cms"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;PHP &amp;mdash; это такой мощный язык программирования на котором можно написать какой-угодно
вебсайт, в зависимости от вашего опыта.
Но ты, уважаемый читатель, даже не подозревал что на PHP можно написать
собственную CMS всего лишь в 8 строк! &lt;/p&gt;
&lt;p&gt;PHP &amp;mdash; это самый крутой язык программирования на планете.&lt;/p&gt;
&lt;!--              этого булшита --&gt;
&lt;p&gt;После прочтение этой научной статьи, ты получишь знание о том как создать свою
крутую CMS в 8 строк!
Ну что же, давай начнем наше путешествие в удивительный мир &lt;!-- психоделического --&gt; PHP!&lt;/p&gt;
&lt;h2&gt;CMS&lt;/h2&gt;
&lt;!-- Пожалуйста, не воспринимайте этот параграф всерьез, это же шутка :) --&gt;
&lt;p&gt;Наша CMS самая крутая и быстрая CMS на всей планете.
Качество PHP кода нашей CMS круче чем качество кода Линуса Тордавльса!&lt;/p&gt;
&lt;p&gt;Давайте начнем с проектирования нашей крутой CMS в 8 строчек.
Нам нужен план. Предлагаю такой план:
&lt;a href="http://macode.ru" target="_blank"&gt;просто написать код&lt;/a&gt;.
Отличный план.&lt;/p&gt;
&lt;p&gt;Я вот написал, а ты следуюешь за мной?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;&amp;lt;?php  

$route = trim(!empty($_GET['route']) ? $_GET['route'] : 'index', '/');

$file = "content/$route";
$file = file_exists("$file.php") ? "$file.php" : 'content/404.php';

ob_start();
$data = require $file;
$content = ob_get_clean();

extract($data ?: []);

include 'theme/layout.php';&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот и вся наша CMS. В папке &lt;code&gt;theme&lt;/code&gt; должны содержатся шаблоны CMS,
а в папке &lt;code&gt;content&lt;/code&gt; должен содержатся контент который должен возвращять массив
с данными.&lt;/p&gt;
&lt;h2&gt;Крутой пример сайта&lt;/h2&gt;
&lt;p&gt;Вот пример сайта (требует apache):&lt;/p&gt;
&lt;div class="tabs-container full"&gt;
    &lt;div class="tab"&gt;index.php&lt;/div&gt;
    &lt;div data-tab="index.php"&gt;
&lt;pre class="language-php"&gt;&lt;code&gt;&amp;lt;?php

$route = trim(!empty($_GET['route']) ? $_GET['route'] : 'index', '/');

$file = "content/$route";
$file = file_exists("$file.php") ? "$file.php" : 'content/404.php';

ob_start();
$data = require $file;
$content = ob_get_clean();

extract($data ?: []);

include 'theme/layout.php';&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;

    &lt;div class="tab"&gt;.htaccess&lt;/div&gt;
    &lt;div data-tab=".htaccess"&gt;
&lt;pre class="language-htaccess"&gt;&lt;code&gt;AddDefaultCharset UTF-8

RewriteEngine On

RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f

RewriteRule (.*) index.php?route=$1 [QSA,L]&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;

    &lt;div class="tab"&gt;theme/index.php&lt;/div&gt;
    &lt;div data-tab="theme/index.php"&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;?php isset($title) and print($title) ?&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;
            &amp;lt;?php isset($title) and print($title) ?&amp;gt;
        &amp;lt;/h1&amp;gt;

        &amp;lt;?php echo $content ?&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;

    &lt;div class="tab"&gt;content/index.php&lt;/div&gt;
    &lt;div data-tab="content/index.php"&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Добро пожаловать! 
    Мой сайт работает на самой крутой и быстрой CMS в мире, 
    которая написана в 8 строк кода.
&amp;lt;/p&amp;gt;

&amp;lt;?php

return [
    'title' =&amp;gt; 'Добро пожаловать'
];&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;

    &lt;div class="tab"&gt;content/404.php&lt;/div&gt;
    &lt;div data-tab="content/404.php"&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Вы наверное не на ту кнопку нажали. 
    По этому попали сюда. Или же потому что я удалил страницу, но не удалил
    внешнии ссылки.
&amp;lt;/p&amp;gt;

&amp;lt;?php

return [
    'title' =&amp;gt; '404 - Страница не была найдена'
];&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Вот и вся CMS. В следующей части &lt;!-- которая вряд ли будет опубликована --&gt;,
я &lt;!-- не --&gt; покажу как создать крутой форум для ДотА сервера на основе
этой CMS.&lt;/p&gt;
&lt;h2&gt;Купите курс&lt;/h2&gt;
&lt;p&gt;Вам понравился эта научная статья, и вы хотите научится писать такой же крутой код
как я?&lt;/p&gt;
&lt;!--               пограммированию --&gt;
&lt;p&gt;Ты хочешь научится программировать на PHP, познать самые крутые паттерны и Дзен PHP
и грести деньги лопатой? Не пропусти этот редкий щанс получить золотую жилу
знаний, купите наш курс и ты получишь все богатсво мира!&lt;/p&gt;
&lt;!-- Нот реалли --&gt;
&lt;p&gt;
    &lt;a class="buy-button" 
       href="javascript:alert('Хе-хе, шутка')" 
       title="Купишь сейчас, получишь скидку в 50%, лимитед оффер"&gt;
        Жми на большую желтую кнопку, купи курс!
    &lt;/a&gt;
&lt;/p&gt;
&lt;!-- А это правда --&gt;
&lt;p&gt;&lt;strong&gt;Забавный факт&lt;/strong&gt;: данный блог начинался именно с этих строк.&lt;/p&gt;
&lt;p&gt;P.S.: 8 строчек PHP кода. Контент, .htaccess конфиг, и шаблоны не идут в счет строчек.
Только index.php&lt;/p&gt;</description>
            <pubDate>Fri, 09 Oct 2015 20:44:03 -0700</pubDate>
        </item>
         
        <item>
            <title>Как использовать PJAX</title>
            
            <link>http://volter9.github.io/blog/pjax-example/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/pjax-example/</guid>
            
            <description>&lt;p&gt;&lt;abbr title="Too Long; Don't Read"&gt;TL;DR&lt;/abbr&gt; – пример внизу.&lt;/p&gt;
&lt;p&gt;Вчера, я наткнулся на плагин &lt;a href="https://github.com/defunkt/jquery-pjax"&gt;PJAX&lt;/a&gt; для
jQuery. Решил я потестировать этот плагин.
К моему сожалению, код из примера не хотел работать с полноценными HTML
документами (без конфигурации приложения, это относится для статических сайтов
вроде моего).&lt;/p&gt;
&lt;p&gt;По этой причине, мне пришлость лезть в исходный код плагина и смотреть в чем проблема.
Изначально я думал что проблема была в том что веб-сервер неправильно обрабатывает
AJAX запросы т.к. Safari консоль не показывала AJAX запрос.&lt;/p&gt;
&lt;p&gt;В итоге вычислилось что все работает, но в исходном код содержимое AJAX запроса
не доходит до точки вывода содержимого в основной контейнер.&lt;/p&gt;
&lt;div class="spoiler spoiler-big"&gt;&lt;pre class="language-js"&gt;&lt;code&gt;function extractContainer() {
  /* ... */

  /**
   * Если не указать в options ключ fragment то содержимое AJAX запроса 
   * не дойдет до места вывода, но это при условие что содержимое AJAX 
   * запроса это полноценный HTML документа с DOCTYPE, html, head и body
   */
  if (options.fragment) {
    // If they specified a fragment, look for it in the response
    // and pull it out.
    if (options.fragment === 'body') {
      var $fragment = $body
    } else {
      var $fragment = findAll($body, options.fragment).first()
    }

    if ($fragment.length) {
      obj.contents = options.fragment === 'body' ? $fragment : $fragment.contents()

      // If there's no title, look for data-title and title attributes
      // on the fragment
      if (!obj.title)
        obj.title = $fragment.attr('title') || $fragment.data('title')
    }

  } else if (!fullDocument) {
    obj.contents = $body
  }

  /* ... */
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; 
&lt;p&gt;Таким образом я потратил впустую пол часа на разгадку &amp;quot;почему же PJAX не работает?&amp;quot;
Было бы намного легче если бы данный плагин кинул исключение с сообщением вроде:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;Ахтунг!&lt;/h2&gt;
&lt;p&gt;Я получил ответ с сервера и это оказался полноценный HTML документ, омг&lt;br /&gt;
Тебе нужно установить fragment свойство в параметрах чтобы я смог нормально
обработать HTML ответ с сервера&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;А теперь сам пример:&lt;/p&gt;
&lt;div class="tabs-container full"&gt;
    &lt;!-- script.js --&gt;
    &lt;div class="tab"&gt;script.js&lt;/div&gt;
    &lt;div data-tab="script.js"&gt;
&lt;pre class="language-js"&gt;&lt;code&gt;$(function () {
    /**
     * PJAX будет срабатывать после нажатие на любую ссылку на странице
     * и загружать фрагмент (контейнер #pjax-container внутри фрагмента) 
     * AJAX запроса в #pjax-container
     */
    $(document).pjax('a', '#pjax-container', {
        fragment: '#pjax-container'
    });
});&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;
    &lt;!-- index.html --&gt;
    &lt;div class="tab"&gt;index.html&lt;/div&gt;
    &lt;div data-tab="index.html"&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Index&amp;lt;/title&amp;gt;

        &amp;lt;script src="//code.jquery.com/jquery-1.11.3.min.js"&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src="jquery.pjax.js"&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src="script.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Заголовок сайта&amp;lt;/h1&amp;gt;

        &amp;lt;div id="pjax-container"&amp;gt;
            &amp;lt;p&amp;gt;
                Привет мир! Чтобы увидеть PJAX в действие, 
                &amp;lt;a href="page.html"&amp;gt;перейдите по этой ссылке&amp;lt;/a&amp;gt;.
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;footer&amp;gt;2015+&amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;

    &lt;!-- page.html --&gt;
    &lt;div class="tab"&gt;page.html&lt;/div&gt;
    &lt;div data-tab="page.html"&gt;
&lt;pre class="language-html"&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Page&amp;lt;/title&amp;gt;

        &amp;lt;script src="//code.jquery.com/jquery-1.11.3.min.js"&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src="jquery.pjax.js"&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src="script.js"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Заголовок сайта&amp;lt;/h1&amp;gt;

        &amp;lt;div id="pjax-container"&amp;gt;
            &amp;lt;p&amp;gt;
                Эта страница должна была загрузится с помощью PJAX.
                Теперь вы увидели PJAX в действие, &amp;lt;a href="index.html"&amp;gt;обратно&amp;lt;/a&amp;gt;?
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;footer&amp;gt;2015+&amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;
&lt;/div&gt;
&lt;p class="notice"&gt;
    Файл jquery.pjax.js нужно скачать с оффициального GitHub репозитория плагина
&lt;/p&gt;
&lt;p&gt;Я думаю что этот пример нужно обязательно добавить в README.md PJAX плагина для
jQuery. Хотя ниже в README, в секции &amp;quot;Response types that force a reload&amp;quot;,
данная проблема описана, жалко что оно там оче.&lt;/p&gt;</description>
            <pubDate>Wed, 07 Oct 2015 17:23:12 -0700</pubDate>
        </item>
         
        <item>
            <title>Простой PHP валидатор</title>
            
            <link>http://volter9.github.io/blog/simple-php-validator/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/simple-php-validator/</guid>
            
            <description>&lt;p&gt;Однажды, один мой знакомый спросил меня, как
&lt;abbr title="Человек который пишет велосипеды"&gt;велосипедиста&lt;/abbr&gt;, как
бы я реализовал простую валидацию данных.
Ну если там несколько полей, то можно делать проверку через &lt;code&gt;empty&lt;/code&gt; или &lt;code&gt;isset&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;if (empty($_POST['name'])) {
    die('Поле "имя" не введено');
}

if (
    empty($_POST['password']) || 
    empty($_POST['password_confirm'])
) {
    die('Поле "пароль" не введено');
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А если нужна более сложная валидация данных то тут необойтись без написание
простой маленькой библиотеки для валидации данных. Встречайте «Валидатор 2000»:&lt;/p&gt;
&lt;div class="spoiler spoiler-big"&gt;&lt;pre class="language-php"&gt;&lt;code&gt;/**
 * Валидатор 2000
 * 
 * @author volter9
 */

/**
 * @param array $data
 * @param array $rules
 * @return array
 */
function validate (array $data, array $rules) {
    $errors = [];

    foreach ($rules as $key =&amp;gt; $rule) {
        $error = validate_field($data[$key], parse_rule($rule), $data);

        if ($error) {
            $errors[$key] = $error;
        }
    }

    return $errors;
}

/**
 * @param mixed $value
 * @param array $rule
 * @param arary $data
 * @return array
 */
function validate_field ($value, array $rule, array $data = []) {
    $errors = [];

    foreach ($rule as $validator =&amp;gt; $args) {
        $vargs = array_merge([$value, $data], $args);

        if (!call_user_func_array($validator, $vargs)) {
            $errors[$validator] = $args;
        }
    }

    return $errors;
}

/**
 * @param string $rule
 * @return array
 */
function parse_rule ($rule) {
    $rule = !$rule ? [] : $rule;

    if (is_array($rule)) {
        return $rule;
    }

    $result = [];
    $rules  = explode('|', $rule);

    foreach ($rules as $rule) {
        $frags = explode(':', $rule);

        $name = $frags[0];
        $args = isset($frags[1]) ? explode(',', $frags[1]) : [];

        $result[$name] = $args;
    }

    return $result;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Как все это работает&lt;/h2&gt;
&lt;p&gt;Чтобы провести валидацию данных нужно воспользоваться функцией &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Функция &lt;code&gt;validate&lt;/code&gt; берет два аргумента: ассоциативный массив с данными и
ассоциативный массив с правилами для этих данных.&lt;/p&gt;
&lt;p&gt;Массив данных может содержать в себе все что угодно. Числа, строки, подмассивы, и т.д.&lt;/p&gt;
&lt;p&gt;Массив с правилами должен содержать в себе пару ключ-значение, где ключ это
название поля в массиве данных, а значение может быть либо форматированной
строкой (упрощенную запись) в виде:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;имя_валидатора|второй_валидатор:с одним аргументом|третий_валидатор:с двумя аргументами,2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Или же значение может быть массивом из ключей-значений где ключ это название валидатора,
а значение это массив с аргументами которые нужно передать в валидатор
(эти значения могут быть чем угодно). Это обычная запись правил для валидации.&lt;/p&gt;
&lt;p&gt;Пример упрощенной и обычной записи правил.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$rules = [
    /* Упрощенная запись */
    'name' =&amp;gt; 'required',

    /* Обычная запись */
    'password' =&amp;gt; [
        'required' =&amp;gt; [],
        'confirm' =&amp;gt; ['password_confirm']
    ]
];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно использовать оба формата в функции &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Когда функция &lt;code&gt;validate&lt;/code&gt; получает массив правил, она сначала приводит правила
в обычную запись с помощью функции &lt;code&gt;parse_rule&lt;/code&gt; (массив с аргументами).
После обработки правила во время каждой итерации данных, функция &lt;code&gt;validate&lt;/code&gt; проводит
валидацию каждого поля с помощью функции &lt;code&gt;validate_field&lt;/code&gt; передавая внутрь значение,
обработанные правила и массив с данными.&lt;/p&gt;
&lt;p&gt;Алгоритм функции &lt;code&gt;validate_field&lt;/code&gt; очень прост. Эта функция получает три аргумента:
значение из массива с данных, правила в обычной форме и входной массив данных
(необязательный аргумент).
Эта функция проходится по всем правилам и вызывает валидаторы на переданном значение,
если значение не проходит валидатор то функция собирает аргументы от валидатора
в массив с ошибками, и возвращает массив с ошибками после окончания итерации.&lt;/p&gt;
&lt;p&gt;На этом все об алгоритме, теперь немного о валидаторах.&lt;/p&gt;
&lt;h2&gt;Валидаторы&lt;/h2&gt;
&lt;p&gt;Для массива правил нужно обозначить валидатор для каждой поля (в виде ключа).
Валидатор это простая пользовательская функция которая должна возвращать булевое значение.
По умолчанию, в эту функцию поступает два параметра: значение поля и массив данных.
Все аргументы которые были переданны в правила идут после этих два аргументов.&lt;/p&gt;
&lt;p&gt;Пример валидатора:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;function required ($value) {
    return !empty($value);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И пример валидатора с дополнительными аргументами:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;function confirm ($value, $array, $field) {
    return isset($array[$field])
        &amp;amp;&amp;amp; (string)$value === (string)$array[$field];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для валидатора выше, нужно передать один аргумент в списке правил для поля:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;// Упрощенная запись
'confirm:password_confirm'

// Обычная запись
[
    'confirm' =&amp;gt; ['password_confirm']
]&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Пример использование библиотеки&lt;/h2&gt;
&lt;p&gt;Пример использования библиотеки:&lt;/p&gt;
&lt;div class="spoiler spoiler-big"&gt;&lt;pre class="language-php"&gt;&lt;code&gt;/** Подключаем валидатор 2000 */
require 'validator.php';

/** Валидаторы */
function required ($value) {
    return !!$value;
}

function confirm ($value, $array, $field) {
    return isset($array[$field])
        &amp;amp;&amp;amp; (string)$value === (string)$array[$field];
}

/**
 * $rules - правила для валидации
 * $pass_data - данные которые пройдут валидацию
 * $fail_data - данные которые не пройдут валидацию
 */

$rules = [
    'name' =&amp;gt; 'required',
    'password' =&amp;gt; 'required|confirm:password_confirm'
];

$pass_data = [
    'name' =&amp;gt; 'Вася Пупкин',
    'password' =&amp;gt; '123456',
    'password_confirm' =&amp;gt; '123456'
];

$fail_data = [
    'name' =&amp;gt; '',
    'password' =&amp;gt; '123456',
    'password_confirm' =&amp;gt; '123'
];

if (!validate($pass_data, $rules)) {
    echo 'Валидация прошла';
}

$errors = validate($fail_data, $rules);

if ($errors) {
    echo 'Произошла ошибка:';

    var_dump($errors);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Также данная библиотека доступна на
&lt;a href="http://gist.github.com/volter9/2d0bf88fceb8bdbfd201"&gt;GitHub Gist&lt;/a&gt;. Лицензия MIT.&lt;/p&gt;</description>
            <pubDate>Tue, 06 Oct 2015 14:02:37 -0700</pubDate>
        </item>
         
        <item>
            <title>Два пробела</title>
            
            <link>http://volter9.github.io/blog/double-space/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/double-space/</guid>
            
            <description>&lt;p&gt;Почему многие JS разработчики используют два пробела для отступа вместо табов или
4-ех пробелов? Это типа модно?&lt;/p&gt;
&lt;p&gt;С двумя пробелами получается каша а не код. Как бы хорошо он не был бы написан,
он все равно нечитабелен. Из-за маленького отступа между строчками плохо виден отступ.
Также, многие JS разработчики не разделяют блоки кода друг от друга логически,
в итоге получается вот такая нечитабельная каша:&lt;/p&gt;
&lt;div class="spoiler spoiler-js"&gt;&lt;pre class="language-code"&gt;&lt;code&gt;// lib/install/flatten-tree.js
'use strict'
var validate = require('aproba')

module.exports = function (tree) {
  validate('O', arguments)
  var seen = {}
  var flat = {}
  var todo = [[tree, '/']]
  while (todo.length) {
    var next = todo.shift()
    var pkg = next[0]
    seen[pkg.path] = true
    var path = next[1]
    flat[path] = pkg
    if (path !== '/') path += '/'
    for (var ii = 0; ii &amp;lt; pkg.children.length; ++ii) {
      var child = pkg.children[ii]
      if (!seen[child.path]) {
        todo.push([child, flatName(path, child)])
      }
    }
  }
  return flat
}

var flatName = module.exports.flatName = function (path, child) {
  validate('SO', arguments)
  return path + (child.package.name || 'TOP')
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p class="notice"&gt;
    Один из исходников 
    &lt;a href="https://github.com/npm/npm/" 
       title="Node Package Manager" 
       target="blank"&gt;NPM&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Мне не удалось с первого раза прочитать этот код и понять что он делать.
Этот код не читабелен.
Вся его проблема читабельности этого кода в том что он слишком сжат.
У нету разделения между блоками и имеется отступ в два пробела.&lt;/p&gt;
&lt;p&gt;После форматирование, код становится более читабельным:&lt;/p&gt;
&lt;div class="spoiler spoiler-js"&gt;&lt;pre class="language-code"&gt;&lt;code&gt;'use strict'

var validate = require('aproba')

module.exports = function (tree) {
    validate('O', arguments)

    var seen = {},
        flat = {},
        todo = [[tree, '/']]

    while (todo.length) {
        var next = todo.shift(),
            pkg  = next[0],
            path = next[1]

        seen[pkg.path] = true
        flat[path] = pkg

        if (path !== '/') path += '/'

        for (var ii = 0; ii &amp;lt; pkg.children.length; ++ii) {
            var child = pkg.children[ii]

            if (!seen[child.path]) {
                todo.push([child, flatName(path, child)])
            }
        }
    }

    return flat
}

var flatName = module.exports.flatName = function (path, child) {
    validate('SO', arguments)

    return path + (child.package.name || 'TOP')
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Все что я сделал это разделил код на логические блоки и заменил отступ в два
пробела на четыре пробела.
Разве код стал более читабельным? По моему, да.&lt;/p&gt;</description>
            <pubDate>Mon, 05 Oct 2015 09:36:44 -0700</pubDate>
        </item>
         
        <item>
            <title>Техника минификации JS кода</title>
            
            <link>http://volter9.github.io/blog/code-minification-techniques/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/code-minification-techniques/</guid>
            
            <description>&lt;p&gt;Недавно для одного проекта я портанул &lt;a href="http://ilyabirman.ru/projects/likely/"&gt;Лайкли&lt;/a&gt;
на ванильный JS. Причина была в том что мне не хотелось тащить jQuery в свой
проект ради социальных кнопок, но кнопки были нужны.&lt;/p&gt;
&lt;p&gt;Тащить jQuery ради одного плагина не очень хотелось, по этому я решил потратить
немножко времени на перевод Лайкли на ванильный JS. За время которое я провел
портатируя Лайкли на ванильный JS я узнал несколько трюков и технику по
минификации JS кода у минификатора кода
&lt;a href="https://www.npmjs.com/package/uglify-js"&gt;uglify-js&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Внимание&lt;/strong&gt;: профессионал в действие, и не &lt;s&gt;повторяйте это&lt;/s&gt; минифицируйте
ничего дома. Дополнительные скобки, комментарии и отступы добавлены с целью
повышения читабельности сжатого кода.&lt;/p&gt;
&lt;h2&gt;Сжатие инструкций&lt;/h2&gt;
&lt;p&gt;Начнем с самого простого. Самое простое &amp;mdash; это сжать несколько
&lt;abbr title="Под инструкцией, я имею ввиду несколько выражений которые разделенны ';'"&gt;инструкций&lt;/abbr&gt;
в одну инструкцию. Сжимая инструкции, минифиактор может сократить код от одной
&lt;code&gt;;&lt;/code&gt; и фигурных скобок.&lt;/p&gt;
&lt;p&gt;Чтобы сжать несколько инструкций вроде вызовов функций/методов, присваивание
значения к уже определенной переменной или другой операции можно воспользоватся
&lt;code&gt;,&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Было 3 отдельных инструкций и вызова к 3-ем методам.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;this.getUserInput();
this.processUserInput();
this.doSomethingElse();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Стало тех же самых три вызова, только теперь это все в одной инструкции и при
этом сэкономили один символ (&lt;code&gt;;&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;this.getUserInput(),
this.processUserInput(),
this.doSomethingElse()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выигрыш небольшой, зато чем больше функций, тем больше экономим &lt;s&gt;на спичках&lt;/s&gt;.&lt;/p&gt;
&lt;h3&gt;Сжатие инструкций и return&lt;/h3&gt;
&lt;p&gt;Сжатие инструкций в функции с &lt;code&gt;return&lt;/code&gt; делается немножко по другому. Допустим,
есть код который вызывает несколько функций и возвращает результат.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/**
 * Типичная инициализация игрового движка на WebGL
 * 
 * @return {WebGLRenderingContext}
 */
function init () {
    initCanvas();
    initGraphicContext();
    initShaders();
    initBuffers();

    return getContext();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы сжать инструкции в этой функции, достаточно переместить все вызовы внутрь
&lt;code&gt;return&lt;/code&gt;, сжать инструкции в одну инструкцию и добавить в конец то что мы хотим
возвратить из функции.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/** ... */
function init () {
    return initCanvas(),
           initGraphicContext(),
           initShaders(),
           initBuffers(),
           getContext()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Запятые в JS работают не только для разделения аргументов в функциях, пары
ключей-значений в ассоциативных массивах и элементы в массивах. С помощью
запятых, можно выполнить несколько выражений в одной инструкции. А результат
последнего выражения в инструкции будет возвращен (как &lt;code&gt;getContext()&lt;/code&gt; в примере
выше).&lt;/p&gt;
&lt;p&gt;В данном случае, выигрыш будет в один символ. Далее следует более продвинутые
варианты экономии места.&lt;/p&gt;
&lt;h2&gt;Сжатие if-else&lt;/h2&gt;
&lt;p&gt;Переходим от простого к более продвинутому способу сжатию кода. Сжать простую
if-else конструкцию можно с помощью тернарного оператора.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;if (is_user_logged_in()) {
    greet_user();
}
else {
    kick_out_user();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Нечитабельно, зато сэкономили на фигурных скобках и ключевых словах.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;is_user_logged_in() ? greet_user() : kick_out_user();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if-elseif-else сжимается таким же образом только с вложенным тернарным
оператором.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;if (is_user_admin()) {
    greet_admin();
}
else if (is_user_logged_in()) {
    greet_user();
}
else {
    kick_out_user();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В итоге получается вот такая нечитабельная конструкция.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;is_user_admin() ? greet_admin : (is_user_logged_in() ? greet_user() : kick_out_user());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Главное чтобы работало, не так ли? С тернарными операторами можно сэкономить
намного больше места в сравнение с сжатия инструкций.&lt;/p&gt;
&lt;h3&gt;Сжатие одного if&lt;/h3&gt;
&lt;p&gt;if-(elseif)-else сжимаются с помощью тернарных выражений в то время как if сам
по себе (без else и else if) сжимается через логические операторы &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt;.
Вот фрагмент кода из минифицированного Лайкли:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/**
 * Получить DOM узел счетчика.
 * Если DOM узел счетчика еще не существует то его надо создать.
 * 
 * @return {jQuery}
 */
getCounterElem: function() {
    var e = this.widget.find("." + u + "counter_single");

    return e.length || (e = t("&amp;lt;span&amp;gt;", {
        "class": c("counter", "single")
    }), this.widget.append(e)), e
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратите внимание на длинное выражение после &lt;code&gt;return&lt;/code&gt;. &lt;code&gt;e.length || (e = ...)&lt;/code&gt;
это то самое место где сжат &lt;code&gt;if&lt;/code&gt;. Тут весь прикол в логике и &lt;code&gt;||&lt;/code&gt; операторе. &lt;/p&gt;
&lt;p&gt;А теперь тот же самый фрагмент кода, только более читабельно и с &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/** ... */
getCounterElem: function() {
    var counter = this.widget.find("." + prefix + "counter_single");

    // e.length || ...
    if (!counter.length) {
        counter = $("&amp;lt;span&amp;gt;", {
            "class": createClass("counter", "single")
        });

        this.widget.append(counter);
    }

    return counter;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Другой пример сжатия &lt;code&gt;if&lt;/code&gt; только с &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/**
 * Получить все data-* значения, обработать значения и 
 * сохранить все это ассоциативный массив this.options
 */
detectParams: function() {
    var t = this.widget.data();
    if (t.counter) {
        var e = parseInt(t.counter, 10);
        isNaN(e) ? this.options.counterUrl = t.counter : this.options.counterNumber = e
    }
    t.title &amp;amp;&amp;amp; (this.options.title = t.title), t.url &amp;amp;&amp;amp; (this.options.url = t.url)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут используется &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; для сжатия двух &lt;code&gt;if&lt;/code&gt; в одну инструкцию. Заметьте,
&lt;code&gt;if (t.counter)&lt;/code&gt; и все что внутри этого &lt;code&gt;if&lt;/code&gt; не может быть сжато в одну
инструкцию т.к. внутри блока имеется объявление переменной &lt;code&gt;e&lt;/code&gt;. Определение
переменных нельзя сжимать, только переназначение уже определенных переменых
можно сжать. &lt;/p&gt;
&lt;p&gt;А читабельный вариант будет выглядить так:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/** ... */
detectParams: function() {
    var data = this.widget.data();

    if (data.counter) {
        var counter = parseInt(data.counter, 10);

        if (isNaN(counter)) {
            this.options.counterUrl = data.counter;
        }
        else {
            this.options.counterNumber = counter;
        }
    }

    // t.title &amp;amp;&amp;amp; ...
    if (data.title) {
        this.options.title = data.title;
    }

    // t.url &amp;amp;&amp;amp; ...
    if (data.url) {
        this.options.url = data.url;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Читабельная версия выглядит намного лучше, но длинее. На &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; можно
сэкономить много места.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Заметка&lt;/strong&gt;: uglify-js убирает условия если эти условия содержут константные
значения и оптимзирует иногда условия внутри &lt;code&gt;if&lt;/code&gt; чтобы сэкономить побольше
места.&lt;/p&gt;
&lt;h2&gt;Сжатие циклов&lt;/h2&gt;
&lt;p&gt;Циклы сжимаются посредством удаления фигурных скобок и сжатием всех выражений
внутри методом который описан выше. Также некоторые минификаторы могут
оптимизировать сжатие в некоторых ситуациях. &lt;/p&gt;
&lt;p&gt;Вот небольшой абстрактный пример сжатия цикла.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var success = false;

while (!success) {
    if (keep_trying() &amp;amp;&amp;amp; is_succeeded()) {
        success = true;
    }

    eat();
    sleep();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут мы опустим фигурные скобки (для одной инструкции они не обязательны),
сожмем &lt;code&gt;if&lt;/code&gt; с помощью &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и воспользуемся &lt;code&gt;,&lt;/code&gt; для сжатия всего тела цикла в
одну инструкцию.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;var success = false;

while(!success)keep_trying() &amp;amp;&amp;amp; is_succeeded() &amp;amp;&amp;amp; (success = true),eat(),sleep()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут нету ничего сложного. Единственное на чем можно сэкономить в циклах это на
фигурных скобках и, в зависимости от ситуации, пару символов на &lt;code&gt;while&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Сжатие литералов&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; тоже можно сжать. &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; сжимается
посредством опретаором &lt;code&gt;!&lt;/code&gt;. Вот простая функция которая определяет является ли
переменная булевом.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;function is_bool (bool) {
    return bool === true || bool === false;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы сжать &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; достаточно воспользоватся оператором &lt;code&gt;!&lt;/code&gt; и &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;/**
 * !0 === true
 * !1 === false
 */
function is_bool (bool) {
    return bool === !0 || bool === !1;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А вот &lt;code&gt;undefined&lt;/code&gt; можно сжать двумя способами: если есть замыкание через
аргумент, через свойство объекта или же через выражение &lt;code&gt;void 0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Сжатие &lt;code&gt;undefined&lt;/code&gt; через замыкание требует определения аргумента в замыкание,
который никогда не будет передан, что сделает его &lt;code&gt;undefined&lt;/code&gt;. Этот метод
требует минификатор или замену &lt;code&gt;undefined&lt;/code&gt; на имя переменной которой вы
дали для замены &lt;code&gt;undefined&lt;/code&gt; в аргументах замыкания.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;(function (undefined) {
    if (a == undefined) {
        a = b == undefined;
    }
    else {
        a = undefined;
    }
})();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И после прогона через минификатор вроде uglify-js мы получим сильно неузнаваемый
укороченный код.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;!function(n){a==n?a=b==n:a=n}()&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Данный пост описывает только некоторые техники минификации кода. uglify-js
делает еще многого всего включая грамотно сжимать название переменных в одну
букву (), удаление комментариев и лишних whitespace (&lt;code&gt; &lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;) символов. &lt;/p&gt;
&lt;p&gt;У минификатор также имеются некоторые ограничения, например: минификаторы не
могут сжимать ключи ассоцитивных массивов при определение внутри &lt;code&gt;{}&lt;/code&gt; литералов
или же при доступе к свойству. Можно было бы сэкономить много места на внутреней
API сжимая имена всех методов и свойств.&lt;/p&gt;</description>
            <pubDate>Sun, 20 Sep 2015 18:06:00 -0700</pubDate>
        </item>
         
        <item>
            <title>Привет мир!</title>
            
            <link>http://volter9.github.io/blog/hello-world/</link>
            <guid isPermaLink="true">http://volter9.github.io/blog/hello-world/</guid>
            
            <description>&lt;p&gt;Добро пожаловать! Меня зовут Евгений, но я также известен под ником volter9.&lt;/p&gt;
&lt;p&gt;В данном блоге я буду писать о веб технологиях (HTML/CSS, PHP, JS) и выкладывать
свои проекты на обозрение. Тут я буду писать разные туториалы, обзоры, идеи,
эксперименты и все что может быть связано с интернетом и веб технологиями. &lt;/p&gt;
&lt;h2&gt;Как со мной связатся&lt;/h2&gt;
&lt;p&gt;Со мной можно связатся можно по почте, Твиттеру или Скайпу (я использую Скайп
как IM). Для того чтобы получить адрес моей почту и/или Скайп, вам прийдется
запустить данный PHP скрипт.&lt;/p&gt;
&lt;div class="spoiler spoiler-big"&gt;&lt;pre class="language-php"&gt;&lt;code&gt;/**
 * Скопируйте и вставьте весь код для получения
 * мыла и Скайпа. 
 */
$base = 'aWJ5Z3JlOTI1QHR6bnZ5LnBieg==';
$mail = base64_decode($base);
$mail = str_rot13($mail); 

echo "Моя почта: $mail";

/**
 * Если не нужен скайп, выполнять код ниже нету смысла
 */
$skype = substr($mail, 0, 7);
$skype = str_replace('9', '_9', $skype);

echo "Мой Скайп: $skype";&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Скрипт очень простой, достаточно его запустить в интерактивной консоле
(&lt;a href="http://php.net/manual/en/features.commandline.interactive.php"&gt;php -a&lt;/a&gt; или
&lt;a href="http://psysh.org/"&gt;psysh&lt;/a&gt;) чтобы получить скайп/почту.&lt;/p&gt;</description>
            <pubDate>Sat, 05 Sep 2015 17:21:00 -0700</pubDate>
        </item>
         
    </channel>
</rss>
