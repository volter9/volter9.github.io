<?xml version="1.0" encoding="utf-8" ?>

<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom' xmlns:dc='http://purl.org/dc/elements/1.1/'>
  <channel>
    <title>
      volter9.github.io
    </title>
    <description>
      Личный блог volter9
    </description>
    <link>
      http://volter9.github.io
    </link>
    <atom:link rel='self' type='application/rss+xml' href='http://volter9.github.io/feed/'>
    </atom:link>
          <item>
        Обновление блога      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/blog-update-v2/      </guid>
      <description>
        &lt;p&gt;Привет всем! Я сделал небольшое обновление блога и теперь он выглядит намного
приятнее предыдущей версии. Кроме этого есть еще пару моментов которых я хотел
описать.&lt;/p&gt;
&lt;h2&gt;Мой блог теперь на GitHub&lt;/h2&gt;
&lt;p&gt;Ну это новость совсем не новая. Вы наверное уже знаете что сайт расположен на
GitHub (благодаря &lt;code&gt;volter9.github.io&lt;/code&gt; домену). Но новость не об этом. Сам исходник
моего сайта лежит на &lt;a href=&quot;https://github.com/volter9/volter9&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Раньше блог был написан на чистом процедурном PHP (код был нормален, но внедрять
фичи было очень сложно в движок, процедура же все таки). По этому я переписал
блог с процедурного PHP на код на основе своего фреймворка для статических
сайтов &lt;a href=&quot;https://github.com/bloge/bloge&quot;&gt;Bloge&lt;/a&gt;. Фреймворк пока что в разработке
(нужно дописать документацию и доработать API), но скоро планирую релиз.&lt;/p&gt;
&lt;h2&gt;Комментарии&lt;/h2&gt;
&lt;p&gt;К сожалению, все комментарии, которые были на сайте (5 штук), были удалены т.к.
при локальном тестирование сайта (просмотр блога и проверка верстки) у меня
произошел небольшой &lt;abbr title=&quot;Я лоханулся&quot;&gt;факап&lt;/abbr&gt;: генератор ссылок
для Disqus генерировал разные абсолютные ссылки в зависимости от среды. По этому
что-то странное произошло с комментариями и ссылками. Мне пришлось удалить сайт с
Disqus и добавить еще раз. По этому все что связано с комментированием
начинается с нового листа.&lt;/p&gt;
&lt;p&gt;На этом все, с наступающим новым годом!&lt;/p&gt;      </description>
      <pubdate>
        Thu, 31 Dec 2015 20:00:00 -0800      </pubdate>
          <item>
        extract и compact      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/php-extract-and-compact/      </guid>
      <description>
        &lt;p&gt;В этом посте я расскажу о двух очень полезных функциях которыми я очень часто
пользуюсь и о которых, наверное, мало кто знает или считает плохой практикой. &lt;/p&gt;
&lt;p&gt;Для начала я скажу что управление областью видимости не является плохой вещью.
По моему мнению, нету плохого и хорошего в программирование. Есть просто разные
инструменты и техники для решение определенных задач.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Внимание&lt;/strong&gt;: в параграфе выше я не утверждаю что нужно пользоватся только
синглетонами, глобальными переменными и &lt;code&gt;goto&lt;/code&gt;. Каждый решает для
себя какую технику использовать и имеет право на мнение против/за разные практики.&lt;/p&gt;
&lt;p&gt;Теперь перейдем к самому интересному, самим функциям &lt;code&gt;extract&lt;/code&gt; и &lt;code&gt;compact&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;extract&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://php.net/manual/en/function.extract.php&quot;&gt;extract&lt;/a&gt; функция распаковывает
значение из ассоциативного массива в данную область видимости. Аналогичный код
который делает тоже самое что и extract с одним аргументом в виде массива:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;foreach ($assoc_array as $key =&amp;gt; $value) {
    $$key = $value;
}

// vs.

extract($assos_array);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данная функция полезна для следующих задач:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Распаковка переменных в шаблонах в кастомном шаблонизаторе на основе PHP/своего
синтаксиса&lt;/li&gt;
&lt;li&gt;Распаковка переменных для облегчения обращение к ключам ассоциативного массива
&lt;code&gt;$config['abc']&lt;/code&gt; → &lt;code&gt;$abc&lt;/code&gt; (но тут нужно точно знать какие ключи существуют)&lt;/li&gt;
&lt;li&gt;Пседо-эмуляция Python &lt;code&gt;**kwargs&lt;/code&gt; в PHP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Пример использования:&lt;/p&gt;
&lt;div class=&quot;tabs-container full&quot;&gt;
    &lt;div class=&quot;tab&quot;&gt;index.php&lt;/div&gt;
    &lt;div data-tab=&quot;index.php&quot;&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code&gt;&amp;lt;?php

/**
 * __ нужны для предотвращения перезаписи переменных
 * 
 * @param string $__view__
 * @param array $__data__
 */
function render ($__view__, $__data__) {
    extract($__data__);

    require($__view__);
}

$title = 'Привет мир!';
$text  = 'Длинный текст...';

render('theme/view.php', [
    'title' =&amp;gt; $title,
    'text'  =&amp;gt; $text
]);&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;

    &lt;div class=&quot;tab&quot;&gt;theme/view.php&lt;/div&gt;
    &lt;div data-tab=&quot;theme/view.php&quot;&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;?php echo $title ?&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;
            &amp;lt;?php echo $title ?&amp;gt; 
        &amp;lt;/h1&amp;gt;

        &amp;lt;p&amp;gt;
            &amp;lt;?php echo $text ?&amp;gt;
        &amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Я уверен что есть еще применение этой функции, но только их пока что не знаю.&lt;/p&gt;
&lt;h2&gt;compact&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://php.net/manual/en/function.compact.php&quot;&gt;compact&lt;/a&gt; функция является
противоположностью функции extract. Данная функция запаковывает массив ключей
или названия переменных, разделенные через запятые, в ассоциативный массив, где
название переменной станет ключем, а значение значением в массиве.&lt;/p&gt;
&lt;p&gt;Эта функция будет полезна в следующих случаях:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Передать из контролера переменные в представление (MVC)&lt;/li&gt;
&lt;li&gt;Вернуть из функции значения переменных в виде массива&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Предыдущий пример можно упростить (укоротить) за счет использования compact:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code&gt;&amp;lt;?php

/**
 * __ нужны для предотвращения перезаписи переменных
 * 
 * @param string $__view__
 * @param array $__data__
 */
function render ($__view__, $__data__) {
    extract($__data__);

    require($__view__);
}

$title = 'Привет мир!';
$text  = 'Длинный текст...';

render('theme/view.php', compact('title', 'text'));&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Эти функции очень полезны для работы с переменными в данной области видимости.
Используйте их там где они нужны. В любом случае, пример был усложнен для
того чтобы показать как работает &lt;code&gt;extract&lt;/code&gt; и &lt;code&gt;compact&lt;/code&gt;. Первый пример можно
упростить до:&lt;/p&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code&gt;&amp;lt;?php

$title = 'Привет мир!';
$text  = 'Длинный текст...';

require 'theme/view.php';&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Всем хорошего дня/вечера!&lt;/p&gt;      </description>
      <pubdate>
        Tue, 03 Nov 2015 20:40:06 -0800      </pubdate>
          <item>
        Трек недели: Bring the Madness      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/bring-the-madness/      </guid>
      <description>
        &lt;p&gt;На этой недели я услышал трек от Pegboard Nerds и был несколько удивлен.
Трек отличается от обычного стиля Pegboard Nerds (видимо из-за коллаба с
Excision и Major Apeshit). Трек мне очень понравился и получился в итоге очень
классным. &lt;/p&gt;
&lt;div&gt;
    &lt;iframe width=&quot;100%&quot; 
            height=&quot;180&quot; 
            scrolling=&quot;no&quot; 
            frameborder=&quot;no&quot; 
            src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/186853816&amp;amp;color=2288dd&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;show_comments=false&amp;amp;show_user=true&amp;amp;show_reposts=true&quot;&gt;
    &lt;/iframe&gt;
&lt;/div&gt;
&lt;p&gt;Огромное влияние на дроп в треке оказал Excision, по моему мнению (больше
похоже на Excision чем Pegboard Nerds).&lt;/p&gt;
&lt;p&gt;Данный трек содержит эпичное вступление которое дает ощущение джунглей.
Агрессивный рэп после краткого вступление поддерживает атмосферу джунглей и дроп
окончательно &lt;!-- &quot;I see what you did here&quot; --&gt; возвыщает трек на новую волну
эфиории.&lt;/p&gt;
&lt;p&gt;В общем, трек и вправду приносит безумие в ума слушателей.&lt;/p&gt;      </description>
      <pubdate>
        Fri, 30 Oct 2015 17:50:17 -0700      </pubdate>
          <item>
        Красивые PHP шаблоны      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/beautiful-php-templates/      </guid>
      <description>
        &lt;p&gt;Привет, данный пост посвящен перфекционистам как я. Бывало у тебя такое что
когда пишешь PHP/Twig шаблоны в итоге вывод получается что-то вроде такого?:&lt;/p&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!-- blocks/navigation --&amp;gt;
&amp;lt;nav class=&quot;navigation&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;/&quot;&amp;gt;
            Главная            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;/blog&quot;&amp;gt;
            Блог            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;/contact&quot;&amp;gt;
            Контакты            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот вывод... это же &lt;em&gt;некрасиво&lt;/em&gt;. PHP шаблон имеет такое содержание:&lt;/p&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!-- blocks/navigation --&amp;gt;
&amp;lt;nav class=&quot;navigation&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;?php foreach ($links as $link): ?&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;&amp;lt;?php echo $link[0] ?&amp;gt;&quot;&amp;gt;
            &amp;lt;?php echo $link[1] ?&amp;gt;
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;?php endforeach; ?&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Да к в чем же проблема? Почему PHP просто не может вывести так как есть в
шаблонах? Что же происходит там в недрах PHP что приводит к искажению
форматирования? Ответ очень прост:&lt;/p&gt;
&lt;p&gt;Закрывающиеся PHP тэги (&lt;code&gt;?&amp;gt;&lt;/code&gt;) удаляют один перенос строки (&lt;code&gt;\n&lt;/code&gt;) в итоге
форматирование шаблонов обрывается. Чтобы предотвратить данную проблему все что
нужно сделать это добавить после каждого &lt;code&gt;?&amp;gt;&lt;/code&gt; пробел.&lt;/p&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!-- blocks/navigation --&amp;gt;
&amp;lt;nav class=&quot;navigation&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;!-- Так намного лучше --&amp;gt;

        &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;/&quot;&amp;gt;
            Главная 
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;

        &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;/blog&quot;&amp;gt;
            Блог 
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;

        &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;/contact&quot;&amp;gt;
            Контакты 
            &amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;

    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот так то лучше! Это вывод того же самого PHP шаблона, только после каждого
закрывающегося PHP тэга добавлен пробел.&lt;/p&gt;
&lt;h3&gt;Вывод&lt;/h3&gt;
&lt;p&gt;К сожалению, нельзя добится полного контроля над форматированием вывода
PHP шаблонов без потери форматирования в исходном коде.&lt;/p&gt;      </description>
      <pubdate>
        Tue, 27 Oct 2015 07:03:35 -0700      </pubdate>
          <item>
        CMS в 8 строк!      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/8-loc-cms/      </guid>
      <description>
        &lt;p&gt;Привет ребята!&lt;/p&gt;
&lt;p&gt;PHP &amp;mdash; такой мощный язык программирования на котором можно написать какой-угодно
вебсайт, в зависимости от вашего опыта.
Но ты, уважаемый читатель, даже не подозревал что на PHP можно написать
собственную CMS всего лишь в 8 строк! &lt;/p&gt;
&lt;p&gt;Короче, PHP это самый крутой язык программирования на планете.&lt;/p&gt;
&lt;p&gt;После прочтение этой научной статьи, ты получишь знание о том как создать свою
крутую CMS в 8 строк!
Ну что же, давай начнем наше путешествие в удивительный мир &lt;!-- психоделического --&gt; PHP!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPD&lt;/strong&gt;: CMS из этой крутой статьи теперь на
&lt;a href=&quot;https://github.com/volter9/8-cms&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Дисклеймер&lt;/strong&gt;: 8 строчек PHP кода. Контент, &lt;code&gt;.htaccess&lt;/code&gt; конфиг, и шаблоны не
идут в счет количества строчек. Только &lt;code&gt;index.php&lt;/code&gt;, только ядро.&lt;/p&gt;
&lt;h2&gt;CMS&lt;/h2&gt;
&lt;!-- Пожалуйста, не воспринимайте этот параграф всерьез, это же шутка :) --&gt;
&lt;p&gt;Наша CMS самая крутая и быстрая CMS на всей планете.
Качество PHP кода нашей CMS круче чем качество кода Линуса Тордавльса!&lt;/p&gt;
&lt;p&gt;Давайте начнем с проектирования нашей крутой CMS в 8 строчек.
Нам нужен план. Предлагаю такой план:
&lt;a href=&quot;http://macode.ru&quot; target=&quot;_blank&quot;&gt;просто написать код&lt;/a&gt;.
Отличный план.&lt;/p&gt;
&lt;p&gt;Я вот написал:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php  

$route = trim(!empty($_GET['route']) ? $_GET['route'] : 'index', '/');

$file = &quot;content/$route&quot;;
$file = file_exists(&quot;$file.php&quot;) ? &quot;$file.php&quot; : 'content/404.php';

ob_start();
$data = require $file;
$content = ob_get_clean();

extract($data ?: []);

include 'theme/layout.php';&lt;/code&gt;&lt;/pre&gt;
&lt;!-- А это правда --&gt;
&lt;p&gt;&lt;strong&gt;Забавный факт&lt;/strong&gt;: данный блог начинался именно с этих строк.&lt;/p&gt;
&lt;p&gt;Вот и вся наша CMS. В папке &lt;code&gt;theme&lt;/code&gt; должны содержатся шаблоны CMS,
а в папке &lt;code&gt;content&lt;/code&gt; должен содержатся контент который должен возвращять массив
с данными.&lt;/p&gt;
&lt;h2&gt;Крутой пример сайта&lt;/h2&gt;
&lt;p&gt;Вот пример сайта (требует apache):&lt;/p&gt;
&lt;div class=&quot;tabs-container full&quot;&gt;
    &lt;div class=&quot;tab&quot;&gt;index.php&lt;/div&gt;
    &lt;div data-tab=&quot;index.php&quot;&gt;
&lt;pre class=&quot;language-php&quot;&gt;&lt;code&gt;&amp;lt;?php

$route = trim(!empty($_GET['route']) ? $_GET['route'] : 'index', '/');

$file = &quot;content/$route&quot;;
$file = file_exists(&quot;$file.php&quot;) ? &quot;$file.php&quot; : 'content/404.php';

ob_start();
$data = require $file;
$content = ob_get_clean();

extract($data ?: []);

include 'theme/layout.php';&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;

    &lt;div class=&quot;tab&quot;&gt;.htaccess&lt;/div&gt;
    &lt;div data-tab=&quot;.htaccess&quot;&gt;
&lt;pre class=&quot;language-htaccess&quot;&gt;&lt;code&gt;AddDefaultCharset UTF-8

RewriteEngine On

RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-f

RewriteRule (.*) index.php?route=$1 [QSA,L]&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;

    &lt;div class=&quot;tab&quot;&gt;theme/index.php&lt;/div&gt;
    &lt;div data-tab=&quot;theme/index.php&quot;&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;?php isset($title) and print($title) ?&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;
            &amp;lt;?php isset($title) and print($title) ?&amp;gt;
        &amp;lt;/h1&amp;gt;

        &amp;lt;?php echo $content ?&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;

    &lt;div class=&quot;tab&quot;&gt;content/index.php&lt;/div&gt;
    &lt;div data-tab=&quot;content/index.php&quot;&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Добро пожаловать! 
    Мой сайт работает на самой крутой и быстрой CMS в мире, 
    которая написана в 8 строк кода.
&amp;lt;/p&amp;gt;

&amp;lt;?php

return [
    'title' =&amp;gt; 'Добро пожаловать'
];&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;

    &lt;div class=&quot;tab&quot;&gt;content/404.php&lt;/div&gt;
    &lt;div data-tab=&quot;content/404.php&quot;&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    Вы наверное не на ту кнопку нажали. 
    По этому попали сюда. Или же потому что я удалил страницу, но не удалил
    внешнии ссылки.
&amp;lt;/p&amp;gt;

&amp;lt;?php

return [
    'title' =&amp;gt; '404 - Страница не была найдена'
];&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Вот и вся CMS. В следующей части &lt;!-- которая вряд ли будет опубликована --&gt;,
я &lt;!-- не --&gt; покажу как создать крутой форум для ДотА сервера на основе
этой CMS.&lt;/p&gt;
&lt;h2&gt;Купите курс&lt;/h2&gt;
&lt;p&gt;Вам понравился эта научная статья, и вы хотите научится писать такой же крутой код
как я?&lt;/p&gt;
&lt;!--               пограммированию --&gt;
&lt;p&gt;Ты хочешь научится программировать на PHP, познать самые крутые паттерны и Дзен PHP
и грести деньги лопатой? Не пропусти этот редкий щанс получить золотую жилу
знаний, купите наш курс и ты получишь все богатсво мира!!!&lt;/p&gt;
&lt;!-- Нот реалли --&gt;
&lt;p style=&quot;text-align: center&quot;&gt;
    &lt;a class=&quot;buy-button&quot; 
       href=&quot;javascript:alert('Хе-хе, шутка')&quot; 
       title=&quot;Купишь сейчас, получишь скидку в 50%, лимитед оффер&quot;&gt;
        Жми кнопку, купи курс!
    &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Также не забудь подписаться на наш канал на ютубе, вк паблик, инстаграм, гугл
плюс, и твиттер аккаунты.&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
    /**
     * Говно код, говнокод, 
     * единственный в мире CSS говнокод
     */
    .buy-button {
        background-color: hsl(40, 95%, 66%); 
        border: 0px !important; 
        border-radius: 8px;
        color: #000; 
        font-size: 24px; 
        font-weight: bold; 
        line-height: 140%;
        text-align: center;

        display: inline-block; 
        padding: 0.85em 2em; 
    }

    .buy-button:hover {
        background-color: hsl(40, 100%, 72%); 
    }
&lt;/style&gt;      </description>
      <pubdate>
        Fri, 09 Oct 2015 20:44:03 -0700      </pubdate>
          <item>
        Как использовать PJAX      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/pjax-example/      </guid>
      <description>
        &lt;p&gt;Вчера я наткнулся на плагин &lt;a href=&quot;https://github.com/defunkt/jquery-pjax&quot;&gt;PJAX&lt;/a&gt; для
jQuery и решил его потестировать. К моему сожалению, код из примера не хотел
работать с полноценными HTML документами (без конфигурации приложения, это
относится для статических сайтов вроде моего).&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
    &lt;abbr title=&quot;Too Long; Don't Read&quot;&gt;TL;DR&lt;/abbr&gt; – пример внизу.
&lt;/p&gt;
&lt;p&gt;По этой причине, мне пришлость лезть в исходный код плагина и смотреть в чем проблема.
Изначально я думал что проблема была в том что веб-сервер неправильно обрабатывает
AJAX запросы т.к. Safari консоль не показывала AJAX запрос.&lt;/p&gt;
&lt;p&gt;В итоге вычислилось что все работает, но в исходном коде содержимое AJAX запроса
не доходит до точки вывода содержимого в основной контейнер.&lt;/p&gt;
&lt;div class=&quot;spoiler spoiler-big&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;function extractContainer() {
  /* ... */

  /**
   * Если не указать в options ключ fragment то содержимое AJAX запроса 
   * не дойдет до места вывода, но это при условие что содержимое AJAX 
   * запроса это полноценный HTML документа с DOCTYPE, html, head и body
   */
  if (options.fragment) {
    // If they specified a fragment, look for it in the response
    // and pull it out.
    if (options.fragment === 'body') {
      var $fragment = $body
    } else {
      var $fragment = findAll($body, options.fragment).first()
    }

    if ($fragment.length) {
      obj.contents = options.fragment === 'body' ? $fragment : $fragment.contents()

      // If there's no title, look for data-title and title attributes
      // on the fragment
      if (!obj.title)
        obj.title = $fragment.attr('title') || $fragment.data('title')
    }

  } else if (!fullDocument) {
    obj.contents = $body
  }

  /* ... */
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; 
&lt;p&gt;Таким образом я потратил впустую пол часа на разгадку &amp;quot;почему же PJAX не работает?&amp;quot;.
Было бы намного легче если бы данный плагин кинул исключение с сообщением вроде:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Я получил ответ с сервера и это оказался полноценный HTML документ, ОМГ  &lt;/p&gt;
&lt;p&gt;Тебе нужно установить свойство fragment в параметрах чтобы я смог нормально
обработать HTML ответ с сервера, хе-хе&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Главное чтобы это сообщение было красным, сверкало и было очень заметным.
А теперь внимание... сам пример:&lt;/p&gt;
&lt;div class=&quot;tabs-container full&quot;&gt;
    &lt;!-- script.js --&gt;
    &lt;div class=&quot;tab&quot;&gt;script.js&lt;/div&gt;
    &lt;div data-tab=&quot;script.js&quot;&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;$(function () {
    /**
     * PJAX будет срабатывать после нажатие на любую ссылку на странице
     * и загружать фрагмент (контейнер #pjax-container внутри фрагмента) 
     * AJAX запроса в #pjax-container
     */
    $(document).pjax('a', '#pjax-container', {
        fragment: '#pjax-container'
    });
});&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;
    &lt;!-- index.html --&gt;
    &lt;div class=&quot;tab&quot;&gt;index.html&lt;/div&gt;
    &lt;div data-tab=&quot;index.html&quot;&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Index&amp;lt;/title&amp;gt;

        &amp;lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&quot;jquery.pjax.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Заголовок сайта&amp;lt;/h1&amp;gt;

        &amp;lt;div id=&quot;pjax-container&quot;&amp;gt;
            &amp;lt;p&amp;gt;
                Привет мир! Чтобы увидеть PJAX в действие, 
                &amp;lt;a href=&quot;page.html&quot;&amp;gt;перейдите по этой ссылке&amp;lt;/a&amp;gt;.
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;footer&amp;gt;2015+&amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;

    &lt;!-- page.html --&gt;
    &lt;div class=&quot;tab&quot;&gt;page.html&lt;/div&gt;
    &lt;div data-tab=&quot;page.html&quot;&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Page&amp;lt;/title&amp;gt;

        &amp;lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&quot;jquery.pjax.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Заголовок сайта&amp;lt;/h1&amp;gt;

        &amp;lt;div id=&quot;pjax-container&quot;&amp;gt;
            &amp;lt;p&amp;gt;
                Эта страница должна была загрузится с помощью PJAX.
                Теперь вы увидели PJAX в действие, &amp;lt;a href=&quot;index.html&quot;&amp;gt;обратно&amp;lt;/a&amp;gt;?
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;footer&amp;gt;2015+&amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;notice&quot;&gt;
    Файл jquery.pjax.js нужно скачать с оффициального GitHub репозитория плагина
&lt;/p&gt;
&lt;p&gt;Я думаю что этот пример нужно обязательно добавить в &lt;code&gt;README.md&lt;/code&gt; PJAX плагина для
jQuery. Хотя ниже в README, в секции &amp;quot;Response types that force a reload&amp;quot;,
данная проблема описана, жалко что описание недостает нужных ключевых слов
т.е. &amp;quot;как запустить PJAX на чистом веб-сервере&amp;quot;.&lt;/p&gt;      </description>
      <pubdate>
        Wed, 07 Oct 2015 17:23:12 -0700      </pubdate>
          <item>
        Простой PHP валидатор      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/simple-php-validator/      </guid>
      <description>
        &lt;p&gt;Однажды, один мой знакомый спросил меня, как
&lt;abbr title=&quot;Человек который пишет велосипеды&quot;&gt;велосипедиста&lt;/abbr&gt;, как
бы я реализовал простую валидацию данных.
Ну если там несколько полей, то можно делать проверку через &lt;code&gt;empty&lt;/code&gt; или &lt;code&gt;isset&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;if (empty($_POST['name'])) {
    die('Поле &quot;имя&quot; не введено');
}

if (
    empty($_POST['password']) || 
    empty($_POST['password_confirm'])
) {
    die('Поле &quot;пароль&quot; не введено');
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А если нужна более сложная валидация данных то тут необойтись без написание
простой маленькой библиотеки для валидации данных. Встречайте «Валидатор 2000»:&lt;/p&gt;
&lt;div class=&quot;spoiler spoiler-big&quot;&gt;&lt;pre class=&quot;language-php&quot;&gt;&lt;code&gt;/**
 * Валидатор 2000
 * 
 * @author volter9
 */

/**
 * @param array $data
 * @param array $rules
 * @return array
 */
function validate (array $data, array $rules) {
    $errors = [];

    foreach ($rules as $key =&amp;gt; $rule) {
        $error = validate_field($data[$key], parse_rule($rule), $data);

        if ($error) {
            $errors[$key] = $error;
        }
    }

    return $errors;
}

/**
 * @param mixed $value
 * @param array $rule
 * @param arary $data
 * @return array
 */
function validate_field ($value, array $rule, array $data = []) {
    $errors = [];

    foreach ($rule as $validator =&amp;gt; $args) {
        $vargs = array_merge([$value, $data], $args);

        if (!call_user_func_array($validator, $vargs)) {
            $errors[$validator] = $args;
        }
    }

    return $errors;
}

/**
 * @param string $rule
 * @return array
 */
function parse_rule ($rule) {
    $rule = !$rule ? [] : $rule;

    if (is_array($rule)) {
        return $rule;
    }

    $result = [];
    $rules  = explode('|', $rule);

    foreach ($rules as $rule) {
        $frags = explode(':', $rule);

        $name = $frags[0];
        $args = isset($frags[1]) ? explode(',', $frags[1]) : [];

        $result[$name] = $args;
    }

    return $result;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Как все это работает&lt;/h2&gt;
&lt;p&gt;Чтобы провести валидацию данных нужно воспользоваться функцией &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Функция &lt;code&gt;validate&lt;/code&gt; берет два аргумента: ассоциативный массив с данными и
ассоциативный массив с правилами для этих данных.&lt;/p&gt;
&lt;p&gt;Массив данных может содержать в себе все что угодно. Числа, строки, подмассивы, и т.д.&lt;/p&gt;
&lt;p&gt;Массив с правилами должен содержать в себе пару ключ-значение, где ключ это
название поля в массиве данных, а значение может быть либо форматированной
строкой (упрощенную запись) в виде:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;имя_валидатора|второй_валидатор:с одним аргументом|третий_валидатор:с двумя аргументами,2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Или же значение может быть массивом из ключей-значений где ключ это название валидатора,
а значение это массив с аргументами которые нужно передать в валидатор
(эти значения могут быть чем угодно). Это обычная запись правил для валидации.&lt;/p&gt;
&lt;p&gt;Пример упрощенной и обычной записи правил.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$rules = [
    /* Упрощенная запись */
    'name' =&amp;gt; 'required',

    /* Обычная запись */
    'password' =&amp;gt; [
        'required' =&amp;gt; [],
        'confirm' =&amp;gt; ['password_confirm']
    ]
];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно использовать оба формата в функции &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Когда функция &lt;code&gt;validate&lt;/code&gt; получает массив правил, она сначала приводит правила
в обычную запись с помощью функции &lt;code&gt;parse_rule&lt;/code&gt; (массив с аргументами).
После обработки правила во время каждой итерации данных, функция &lt;code&gt;validate&lt;/code&gt; проводит
валидацию каждого поля с помощью функции &lt;code&gt;validate_field&lt;/code&gt; передавая внутрь значение,
обработанные правила и массив с данными.&lt;/p&gt;
&lt;p&gt;Алгоритм функции &lt;code&gt;validate_field&lt;/code&gt; очень прост. Эта функция получает три аргумента:
значение из массива с данных, правила в обычной форме и входной массив данных
(необязательный аргумент).
Эта функция проходится по всем правилам и вызывает валидаторы на переданном значение,
если значение не проходит валидатор то функция собирает аргументы от валидатора
в массив с ошибками, и возвращает массив с ошибками после окончания итерации.&lt;/p&gt;
&lt;p&gt;На этом все об алгоритме, теперь немного о валидаторах.&lt;/p&gt;
&lt;h2&gt;Валидаторы&lt;/h2&gt;
&lt;p&gt;Для массива правил нужно обозначить валидатор для каждой поля (в виде ключа).
Валидатор это простая пользовательская функция которая должна возвращать булевое значение.
По умолчанию, в эту функцию поступает два параметра: значение поля и массив данных.
Все аргументы которые были переданны в правила идут после этих два аргументов.&lt;/p&gt;
&lt;p&gt;Пример валидатора:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;function required ($value) {
    return !empty($value);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И пример валидатора с дополнительными аргументами:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;function confirm ($value, $array, $field) {
    return isset($array[$field])
        &amp;amp;&amp;amp; (string)$value === (string)$array[$field];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для валидатора выше, нужно передать один аргумент в списке правил для поля:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Упрощенная запись
'confirm:password_confirm'

// Обычная запись
[
    'confirm' =&amp;gt; ['password_confirm']
]&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Пример использование библиотеки&lt;/h2&gt;
&lt;p&gt;Пример использования библиотеки:&lt;/p&gt;
&lt;div class=&quot;spoiler spoiler-big&quot;&gt;&lt;pre class=&quot;language-php&quot;&gt;&lt;code&gt;/** Подключаем валидатор 2000 */
require 'validator.php';

/** Валидаторы */
function required ($value) {
    return !!$value;
}

function confirm ($value, $array, $field) {
    return isset($array[$field])
        &amp;amp;&amp;amp; (string)$value === (string)$array[$field];
}

/**
 * $rules - правила для валидации
 * $pass_data - данные которые пройдут валидацию
 * $fail_data - данные которые не пройдут валидацию
 */

$rules = [
    'name' =&amp;gt; 'required',
    'password' =&amp;gt; 'required|confirm:password_confirm'
];

$pass_data = [
    'name' =&amp;gt; 'Вася Пупкин',
    'password' =&amp;gt; '123456',
    'password_confirm' =&amp;gt; '123456'
];

$fail_data = [
    'name' =&amp;gt; '',
    'password' =&amp;gt; '123456',
    'password_confirm' =&amp;gt; '123'
];

if (!validate($pass_data, $rules)) {
    echo 'Валидация прошла';
}

$errors = validate($fail_data, $rules);

if ($errors) {
    echo 'Произошла ошибка:';

    var_dump($errors);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Также данная библиотека доступна на
&lt;a href=&quot;http://gist.github.com/volter9/2d0bf88fceb8bdbfd201&quot;&gt;GitHub Gist&lt;/a&gt;. Лицензия MIT.&lt;/p&gt;      </description>
      <pubdate>
        Tue, 06 Oct 2015 14:02:37 -0700      </pubdate>
          <item>
        Два пробела      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/double-space/      </guid>
      <description>
        &lt;p&gt;Почему многие JS разработчики используют два пробела для отступа вместо табов или
4-ех пробелов? Это типа модно?&lt;/p&gt;
&lt;p&gt;С двумя пробелами получается каша а не код. Как бы хорошо он не был бы написан,
он все равно нечитабелен. Из-за маленького отступа между строчками плохо виден отступ.
Также, многие JS разработчики не разделяют блоки кода друг от друга логически,
в итоге получается вот такая нечитабельная каша:&lt;/p&gt;
&lt;div class=&quot;spoiler spoiler-js&quot;&gt;&lt;pre class=&quot;language-code&quot;&gt;&lt;code&gt;'use strict'
var validate = require('aproba')

module.exports = function (tree) {
  validate('O', arguments)
  var seen = {}
  var flat = {}
  var todo = [[tree, '/']]
  while (todo.length) {
    var next = todo.shift()
    var pkg = next[0]
    seen[pkg.path] = true
    var path = next[1]
    flat[path] = pkg
    if (path !== '/') path += '/'
    for (var ii = 0; ii &amp;lt; pkg.children.length; ++ii) {
      var child = pkg.children[ii]
      if (!seen[child.path]) {
        todo.push([child, flatName(path, child)])
      }
    }
  }
  return flat
}

var flatName = module.exports.flatName = function (path, child) {
  validate('SO', arguments)
  return path + (child.package.name || 'TOP')
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;notice&quot;&gt;
    Один из исходников 
    &lt;a href=&quot;https://github.com/npm/npm/blob/d2178a9ea034ede58f02919f259ee072a6554c59/lib/install/flatten-tree.js&quot; 
       title=&quot;Node Package Manager&quot; 
       target=&quot;blank&quot;&gt;NPM&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Мне не удалось с первого раза прочитать этот код и понять что он делать.
Этот код не читабелен.
Вся его проблема читабельности этого кода в том что он слишком сжат.
У нету разделения между блоками и имеется отступ в два пробела.&lt;/p&gt;
&lt;p&gt;После форматирование, код становится более читабельным:&lt;/p&gt;
&lt;div class=&quot;spoiler spoiler-js&quot;&gt;&lt;pre class=&quot;language-code&quot;&gt;&lt;code&gt;'use strict'

var validate = require('aproba')

module.exports = function (tree) {
    validate('O', arguments)

    var seen = {},
        flat = {},
        todo = [[tree, '/']]

    while (todo.length) {
        var next = todo.shift(),
            pkg  = next[0],
            path = next[1]

        seen[pkg.path] = true
        flat[path] = pkg

        if (path !== '/') path += '/'

        for (var ii = 0; ii &amp;lt; pkg.children.length; ++ii) {
            var child = pkg.children[ii]

            if (!seen[child.path]) {
                todo.push([child, flatName(path, child)])
            }
        }
    }

    return flat
}

var flatName = module.exports.flatName = function (path, child) {
    validate('SO', arguments)

    return path + (child.package.name || 'TOP')
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Все что я сделал это разделил код на логические блоки и заменил отступ в два
пробела на четыре пробела.
Разве код стал более читабельным? По моему, да.&lt;/p&gt;      </description>
      <pubdate>
        Mon, 05 Oct 2015 09:36:44 -0700      </pubdate>
          <item>
        Техника минификации JS кода      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/code-minification-techniques/      </guid>
      <description>
        &lt;p&gt;Недавно для одного проекта я портанул &lt;a href=&quot;http://ilyabirman.ru/projects/likely/&quot;&gt;Лайкли&lt;/a&gt;
на ванильный JS. Причина была в том что мне не хотелось тащить jQuery в свой
проект ради социальных кнопок, но кнопки были нужны.&lt;/p&gt;
&lt;p&gt;Тащить jQuery ради одного плагина не очень хотелось, по этому я решил потратить
немножко времени на перевод Лайкли на ванильный JS. За время которое я провел
портатируя Лайкли на ванильный JS я узнал несколько трюков и технику по
минификации JS кода у минификатора кода
&lt;a href=&quot;https://www.npmjs.com/package/uglify-js&quot;&gt;uglify-js&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Внимание&lt;/strong&gt;: профессионал в действие, и не &lt;s&gt;повторяйте это&lt;/s&gt; минифицируйте
ничего дома. Дополнительные скобки, комментарии и отступы добавлены с целью
повышения читабельности сжатого кода.&lt;/p&gt;
&lt;h2&gt;Сжатие инструкций&lt;/h2&gt;
&lt;p&gt;Начнем с самого простого. Самое простое &amp;mdash; это сжать несколько
&lt;abbr title=&quot;Под инструкцией, я имею ввиду несколько выражений которые разделенны ';'&quot;&gt;инструкций&lt;/abbr&gt;
в одну инструкцию. Сжимая инструкции, минифиактор может сократить код от одной
&lt;code&gt;;&lt;/code&gt; и фигурных скобок.&lt;/p&gt;
&lt;p&gt;Чтобы сжать несколько инструкций вроде вызовов функций/методов, присваивание
значения к уже определенной переменной или другой операции можно воспользоватся
&lt;code&gt;,&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Было 3 отдельных инструкций и вызова к 3-ем методам.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.getUserInput();
this.processUserInput();
this.doSomethingElse();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Стало тех же самых три вызова, только теперь это все в одной инструкции и при
этом сэкономили один символ (&lt;code&gt;;&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;this.getUserInput(),
this.processUserInput(),
this.doSomethingElse()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выигрыш небольшой, зато чем больше функций, тем больше экономим &lt;s&gt;на спичках&lt;/s&gt;.&lt;/p&gt;
&lt;h3&gt;Сжатие инструкций и return&lt;/h3&gt;
&lt;p&gt;Сжатие инструкций в функции с &lt;code&gt;return&lt;/code&gt; делается немножко по другому. Допустим,
есть код который вызывает несколько функций и возвращает результат.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/**
 * Типичная инициализация игрового движка на WebGL
 * 
 * @return {WebGLRenderingContext}
 */
function init () {
    initCanvas();
    initGraphicContext();
    initShaders();
    initBuffers();

    return getContext();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы сжать инструкции в этой функции, достаточно переместить все вызовы внутрь
&lt;code&gt;return&lt;/code&gt;, сжать инструкции в одну инструкцию и добавить в конец то что мы хотим
возвратить из функции.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/** ... */
function init () {
    return initCanvas(),
           initGraphicContext(),
           initShaders(),
           initBuffers(),
           getContext()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Запятые в JS работают не только для разделения аргументов в функциях, пары
ключей-значений в ассоциативных массивах и элементы в массивах. С помощью
запятых, можно выполнить несколько выражений в одной инструкции. А результат
последнего выражения в инструкции будет возвращен (как &lt;code&gt;getContext()&lt;/code&gt; в примере
выше).&lt;/p&gt;
&lt;p&gt;В данном случае, выигрыш будет в один символ. Далее следует более продвинутые
варианты экономии места.&lt;/p&gt;
&lt;h2&gt;Сжатие if-else&lt;/h2&gt;
&lt;p&gt;Переходим от простого к более продвинутому способу сжатию кода. Сжать простую
if-else конструкцию можно с помощью тернарного оператора.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (is_user_logged_in()) {
    greet_user();
}
else {
    kick_out_user();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Нечитабельно, зато сэкономили на фигурных скобках и ключевых словах.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;is_user_logged_in() ? greet_user() : kick_out_user();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if-elseif-else сжимается таким же образом только с вложенным тернарным
оператором.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (is_user_admin()) {
    greet_admin();
}
else if (is_user_logged_in()) {
    greet_user();
}
else {
    kick_out_user();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В итоге получается вот такая нечитабельная конструкция.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;is_user_admin() ? greet_admin : (is_user_logged_in() ? greet_user() : kick_out_user());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Главное чтобы работало, не так ли? С тернарными операторами можно сэкономить
намного больше места в сравнение с сжатия инструкций.&lt;/p&gt;
&lt;h3&gt;Сжатие одного if&lt;/h3&gt;
&lt;p&gt;if-(elseif)-else сжимаются с помощью тернарных выражений в то время как if сам
по себе (без else и else if) сжимается через логические операторы &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt;.
Вот фрагмент кода из минифицированного Лайкли:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/**
 * Получить DOM узел счетчика.
 * Если DOM узел счетчика еще не существует то его надо создать.
 * 
 * @return {jQuery}
 */
getCounterElem: function() {
    var e = this.widget.find(&quot;.&quot; + u + &quot;counter_single&quot;);

    return e.length || (e = t(&quot;&amp;lt;span&amp;gt;&quot;, {
        &quot;class&quot;: c(&quot;counter&quot;, &quot;single&quot;)
    }), this.widget.append(e)), e
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратите внимание на длинное выражение после &lt;code&gt;return&lt;/code&gt;. &lt;code&gt;e.length || (e = ...)&lt;/code&gt;
это то самое место где сжат &lt;code&gt;if&lt;/code&gt;. Тут весь прикол в логике и &lt;code&gt;||&lt;/code&gt; операторе. &lt;/p&gt;
&lt;p&gt;А теперь тот же самый фрагмент кода, только более читабельно и с &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/** ... */
getCounterElem: function() {
    var counter = this.widget.find(&quot;.&quot; + prefix + &quot;counter_single&quot;);

    // e.length || ...
    if (!counter.length) {
        counter = $(&quot;&amp;lt;span&amp;gt;&quot;, {
            &quot;class&quot;: createClass(&quot;counter&quot;, &quot;single&quot;)
        });

        this.widget.append(counter);
    }

    return counter;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Другой пример сжатия &lt;code&gt;if&lt;/code&gt; только с &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/**
 * Получить все data-* значения, обработать значения и 
 * сохранить все это ассоциативный массив this.options
 */
detectParams: function() {
    var t = this.widget.data();
    if (t.counter) {
        var e = parseInt(t.counter, 10);
        isNaN(e) ? this.options.counterUrl = t.counter : this.options.counterNumber = e
    }
    t.title &amp;amp;&amp;amp; (this.options.title = t.title), t.url &amp;amp;&amp;amp; (this.options.url = t.url)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут используется &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; для сжатия двух &lt;code&gt;if&lt;/code&gt; в одну инструкцию. Заметьте,
&lt;code&gt;if (t.counter)&lt;/code&gt; и все что внутри этого &lt;code&gt;if&lt;/code&gt; не может быть сжато в одну
инструкцию т.к. внутри блока имеется объявление переменной &lt;code&gt;e&lt;/code&gt;. Определение
переменных нельзя сжимать, только переназначение уже определенных переменых
можно сжать. &lt;/p&gt;
&lt;p&gt;А читабельный вариант будет выглядить так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/** ... */
detectParams: function() {
    var data = this.widget.data();

    if (data.counter) {
        var counter = parseInt(data.counter, 10);

        if (isNaN(counter)) {
            this.options.counterUrl = data.counter;
        }
        else {
            this.options.counterNumber = counter;
        }
    }

    // t.title &amp;amp;&amp;amp; ...
    if (data.title) {
        this.options.title = data.title;
    }

    // t.url &amp;amp;&amp;amp; ...
    if (data.url) {
        this.options.url = data.url;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Читабельная версия выглядит намного лучше, но длинее. На &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; можно
сэкономить много места.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Заметка&lt;/strong&gt;: uglify-js убирает условия если эти условия содержут константные
значения и оптимзирует иногда условия внутри &lt;code&gt;if&lt;/code&gt; чтобы сэкономить побольше
места.&lt;/p&gt;
&lt;h2&gt;Сжатие циклов&lt;/h2&gt;
&lt;p&gt;Циклы сжимаются посредством удаления фигурных скобок и сжатием всех выражений
внутри методом который описан выше. Также некоторые минификаторы могут
оптимизировать сжатие в некоторых ситуациях. &lt;/p&gt;
&lt;p&gt;Вот небольшой абстрактный пример сжатия цикла.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var success = false;

while (!success) {
    if (keep_trying() &amp;amp;&amp;amp; is_succeeded()) {
        success = true;
    }

    eat();
    sleep();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут мы опустим фигурные скобки (для одной инструкции они не обязательны),
сожмем &lt;code&gt;if&lt;/code&gt; с помощью &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и воспользуемся &lt;code&gt;,&lt;/code&gt; для сжатия всего тела цикла в
одну инструкцию.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var success = false;

while(!success)keep_trying() &amp;amp;&amp;amp; is_succeeded() &amp;amp;&amp;amp; (success = true),eat(),sleep()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут нету ничего сложного. Единственное на чем можно сэкономить в циклах это на
фигурных скобках и, в зависимости от ситуации, пару символов на &lt;code&gt;while&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Сжатие литералов&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; тоже можно сжать. &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; сжимается
посредством опретаором &lt;code&gt;!&lt;/code&gt;. Вот простая функция которая определяет является ли
переменная булевом.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function is_bool (bool) {
    return bool === true || bool === false;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы сжать &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; достаточно воспользоватся оператором &lt;code&gt;!&lt;/code&gt; и &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/**
 * !0 === true
 * !1 === false
 */
function is_bool (bool) {
    return bool === !0 || bool === !1;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А вот &lt;code&gt;undefined&lt;/code&gt; можно сжать двумя способами: если есть замыкание через
аргумент, через свойство объекта или же через выражение &lt;code&gt;void 0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Сжатие &lt;code&gt;undefined&lt;/code&gt; через замыкание требует определения аргумента в замыкание,
который никогда не будет передан, что сделает его &lt;code&gt;undefined&lt;/code&gt;. Этот метод
требует минификатор или замену &lt;code&gt;undefined&lt;/code&gt; на имя переменной которой вы
дали для замены &lt;code&gt;undefined&lt;/code&gt; в аргументах замыкания.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;(function (undefined) {
    if (a == undefined) {
        a = b == undefined;
    }
    else {
        a = undefined;
    }
})();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И после прогона через минификатор вроде uglify-js мы получим сильно неузнаваемый
укороченный код.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;!function(n){a==n?a=b==n:a=n}()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выглядит сногсшибательно.&lt;/p&gt;
&lt;h2&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Данный пост описывает только некоторые техники минификации кода. uglify-js
делает еще многого всего включая грамотно сжимать название переменных в одну
букву (), удаление комментариев и лишних whitespace (&lt;code&gt; &lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;) символов. &lt;/p&gt;
&lt;p&gt;У минификатор также имеются некоторые ограничения, например: минификаторы не
могут сжимать ключи ассоцитивных массивов при определение внутри &lt;code&gt;{}&lt;/code&gt; литералов
или же при доступе к свойству. Можно было бы сэкономить много места на внутреней
API сжимая имена всех методов и свойств.&lt;/p&gt;      </description>
      <pubdate>
        Sun, 20 Sep 2015 18:06:00 -0700      </pubdate>
          <item>
        Привет мир!      </item>
      <guid isPermaLink='isPermaLink'>
        http://volter9.github.io/blog/hello-world/      </guid>
      <description>
        &lt;p&gt;Добро пожаловать! Меня зовут Евгений, но я также известен под ником volter9.&lt;/p&gt;
&lt;p&gt;В данном блоге я буду писать о веб технологиях (HTML/CSS, PHP, JS) и выкладывать
свои проекты на обозрение. Тут я буду писать разные туториалы, обзоры, идеи,
эксперименты и все что может быть связано с интернетом и веб технологиями. &lt;/p&gt;      </description>
      <pubdate>
        Sat, 05 Sep 2015 17:21:00 -0700      </pubdate>
      </channel>
</rss>
